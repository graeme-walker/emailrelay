#!/bin/sh
#
# Copyright (C) 2001-2003 Graeme Walker <graeme_walker@users.sourceforge.net>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later
# version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
# 
# ===
# 
# emailrelay
# 
# A shell-script wrapper for E-MailRelay designed for
# use in the SysV-init system (/etc/init.d).
#
# See also: LSB, start_daemon (lsb), startproc (suse), 
# install_initd (lsb), insserv (suse),
# /usr/share/doc/initscripts*/sysvinitfiles (redhat)
#
# usage: emailrelay { start [<emailrelay-switches>] | stop | restart | force-reload | status }
#
##
# RedHat comment block...
#
# chkconfig: 345 80 20
# description: E-MailRelay is a store-and-forward Message Transfer Agent.
# pidfile: /var/run/emailrelay.pid
# processname: emailrelay
# 
##
# LSB comment block...
#
# The bogus 345 run-levels are a workround for a buggy RedHat chkconfig which 
# reads the LSB comment block (incorrectly) as an undocumented 'feature'.
#
### BEGIN INIT INFO
# Provides:       emailrelay
# Required-Start: $network
# Required-Stop:  $network
# Default-Start:  345 3 4 5
# Default-Stop:   345 3 4 5
# Description:    E-MailRelay store-and-forward Message Transfer Agent.
### END INIT INFO

# choose an infrastructure style
#
if test -f /etc/rc.status 
then 
	style="suse"
	. /etc/rc.status
elif test -f /etc/init.d/functions
then 
	style="redhat" 
	. /etc/init.d/functions
elif test -f /lib/lsb/init-functions
then 
	style="lsb" 
	. /lib/lsb/init-functions
else
	style="unix"
fi

# configuration
#
switches=""
sbin="/sbin"
var_run="/var/run"
emailrelay="__SBIN_DIR__/emailrelay"
if test \! -d "${var_run}" ; then var_run="/tmp" ; fi
if test \! -x "${emailrelay}" ; then emailrelay="./emailrelay" ; fi
pid_file="${var_run}/emailrelay.pid"
PATH="${PATH}:/sbin:/bin:/usr/bin"

# functions...
#
# <style>_reset() -- initialise
# <style>_message() -- do echo -n
# <style>_status() [-v] -- save errno and say ok/failed for -v
# <style>_startproc() -- start the server
# <style>_killproc() -- kill the server
# <style>_checkproc() -- return true if running
# <style>_exit() -- exit with saved errno

function unix_reset()
{
	unix_errno="0"
}

function unix_message()
{
	echo -n "${1}"
}

function unix_status()
{
	unix_errno="$?"
	if test "${1}" = "-v" -a "${unix_errno}" -eq 0
	then
		echo " ... done" 
	fi
	if test "${1}" = "-v" -a "${unix_errno}" -ne 0
	then
		echo " ... failed" 
	fi
}

function unix_startproc()
{
	$@
}

function unix_killproc()
{
	if test -f "${pid_file}" && test "`cat ${pid_file}`" != ""
	then
		kill "`cat ${pid_file}`"
		rm -f "${pid_file}" 2>/dev/null
	fi
	return 0
}

function unix_checkproc()
{
	if test -f "${pid_file}" && test "`cat ${pid_file}`" != "" && kill -0 "`cat ${pid_file}`" 2>/dev/null
	then
		return 0
	elif test -f "${pid_file}" 
	then
		return 1
	else
		return 3
	fi
}

function unix_exit()
{
	exit "${unix_errno}"
}

##

function redhat_reset()
{
	redhat_errno="0"
}

function redhat_message()
{
	echo -n "${1}"
}

function redhat_status()
{
	redhat_errno="$?"
	if test "${1}" = "-v" -a "${redhat_errno}" -eq 0
	then
		success
	fi
	if test "${1}" = "-v" -a "${redhat_errno}" -ne 0
	then
		failure
	fi
}

function redhat_startproc()
{
	initlog -q --cmd="$*"
	redhat_errno="$?"
	#touch /var/lock/subsys/emailrelay
	return ${redhat_errno}
}

function redhat_killproc()
{
	killproc "`basename ${emailrelay}`"
	redhat_errno="$?"
	#rm -f /var/lock/subsys/emailrelay
	return ${redhat_errno}
}

function redhat_checkproc()
{
	if test -f "${pid_file}" && test "`cat ${pid_file}`" != "" && kill -0 "`cat ${pid_file}`" 2>/dev/null
	then
		return 0
	elif test -f "${pid_file}" 
	then
		return 1
	else
		return 3
	fi
}

function redhat_exit()
{
	exit "${redhat_errno}"
}

##

function suse_reset()
{
	rc_reset
}

function suse_message()
{
	echo -n "${1}"
}

function suse_status()
{
	rc_status $@
}

function suse_startproc()
{
	startproc $@
}

function suse_killproc()
{
	killproc $@
}

function suse_checkproc()
{
	checkproc $@
}

function suse_exit()
{
	rc_exit
}

##

function lsb_reset()
{
	lsb_errno="0"
	lsb_text=""
}

function lsb_message()
{
	lsb_text="$@"
}

function lsb_status()
{
	lsb_errno=$?
	if test "${lsb_errno}" -eq 0 -a "${1}" = "-v"
	then
		log_success_msg "${lsb_text}: done"
	elif test "${1}" = "-v"
	then
		log_failure_msg "${lsb_text}: failed"
	fi
}

function lsb_startproc()
{
	start_daemon $@
}

function lsb_killproc()
{
	killproc "`basename \"${1}\"`"
}

function lsb_checkproc()
{
	base="`basename \"${1}\"`"
	pids="`pidofproc \"${base}\" | sed 's/ *$//'`"
	test "${pids}" != ""
}

function lsb_exit()
{
	exit ${lsb_errno}
}

# check the command line
#
usage="{ start [<server-switches>] | stop | restart | force-reload | status }"
if test $# -eq 0
then
	echo usage: `basename $0` "${usage}" >&2
	exit 2
fi

# process the command line
#
${style}_reset
case "${1}" in

	start)
		shift
		${style}_message "Starting E-MailRelay server"
		${style}_startproc ${emailrelay} --as-server --pid-file "${pid_file}" ${switches} $@
		${style}_status -v
		;;

	stop)
		${style}_message "Shutting down E-MailRelay"
		${style}_killproc "${emailrelay}"
		${style}_status -v
		;;

	restart|force-reload)
		shift
		$0 stop
		$0 start $@
		${style}_status
		;;

	reload)
		echo usage: `basename $0` reload: not implemented >&2
		exit 3
		;;

	status)
		${style}_message "Checking for E-MailRelay"
		${style}_checkproc "${emailrelay}"
		${style}_status -v
		;;

	*)
		echo usage: `basename $0` "${usage}" >&2
		exit 2
		;;
esac
${style}_exit

